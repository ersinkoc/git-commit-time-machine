/**
 * Git Commit Time Machine Main Class - Comprehensive Tests
 */

const GitCommitTimeMachine = require('../src/index');
const fs = require('fs-extra');
const path = require('path');
const os = require('os');

describe('GitCommitTimeMachine (Main Class)', () => {
  let gctm;
  let testRepoPath;

  beforeEach(async () => {
    // Create temporary test directory
    testRepoPath = await fs.mkdtemp(path.join(os.tmpdir(), 'gctm-main-test-'));

    // Initialize git repo
    const simpleGit = require('simple-git');
    const git = simpleGit({ baseDir: testRepoPath });
    await git.init();
    await git.addConfig('user.name', 'Test User');
    await git.addConfig('user.email', 'test@example.com');
    await git.addConfig('commit.gpgsign', 'false');

    // Create test commits
    await fs.writeFile(path.join(testRepoPath, 'test.txt'), 'Initial content');
    await git.add(['test.txt']);
    await git.commit('Initial commit');

    gctm = new GitCommitTimeMachine({ repoPath: testRepoPath });
  });

  afterEach(async () => {
    await fs.remove(testRepoPath);
  });

  describe('Constructor and Initialization', () => {
    test('should create instance with default options', () => {
      const instance = new GitCommitTimeMachine();
      expect(instance.repoPath).toBe(process.cwd());
      expect(instance.gitProcessor).toBeDefined();
      expect(instance.dateManager).toBeDefined();
      expect(instance.contentEditor).toBeDefined();
      expect(instance.backupManager).toBeDefined();
      expect(instance.aiAssistant).toBeDefined();
    });

    test('should create instance with custom options', () => {
      const options = {
        repoPath: testRepoPath,
        ai: {
          apiKey: 'test-key',
          provider: 'anthropic'
        }
      };

      const instance = new GitCommitTimeMachine(options);
      expect(instance.repoPath).toBe(testRepoPath);
      expect(instance.aiAssistant.apiKey).toBe('test-key');
      expect(instance.aiAssistant.apiProvider).toBe('anthropic');
    });

    test('should initialize all sub-modules correctly', () => {
      expect(gctm.gitProcessor.repoPath).toBe(testRepoPath);
      expect(gctm.contentEditor.repoPath).toBe(testRepoPath);
      expect(gctm.backupManager.repoPath).toBe(testRepoPath);
    });
  });

  describe('Commit Redating', () => {
    test('should redate commits successfully', async () => {
      // Create another commit
      const simpleGit = require('simple-git');
      const git = simpleGit({ baseDir: testRepoPath });
      await fs.writeFile(path.join(testRepoPath, 'test2.txt'), 'Second content');
      await git.add(['test2.txt']);
      await git.commit('Second commit');

      const options = {
        startDate: '2023-01-01',
        endDate: '2023-01-05',
        createBackup: true
      };

      const result = await gctm.redateCommits(options);

      expect(result.success).toBe(true);
      expect(result.processed).toBeGreaterThan(0);
      expect(result.total).toBeGreaterThan(0);
    });

    test('should handle invalid date range', async () => {
      const options = {
        startDate: 'invalid-date',
        endDate: '2023-01-05',
        createBackup: false
      };

      const result = await gctm.redateCommits(options);

      expect(result.success).toBe(false);
      expect(result.error).toContain('Date validation failed');
    });

    test('should handle start date after end date', async () => {
      const options = {
        startDate: '2023-01-10',
        endDate: '2023-01-05',
        createBackup: false
      };

      const result = await gctm.redateCommits(options);

      expect(result.success).toBe(false);
      expect(result.error).toContain('Date validation failed');
    });

    test('should handle no commits found', async () => {
      // Create empty repo with no commits
      const emptyDir = await fs.mkdtemp(path.join(os.tmpdir(), 'empty-repo-'));
      const simpleGit = require('simple-git');
      const git = simpleGit({ baseDir: emptyDir });
      await git.init();
      await git.addConfig('user.name', 'Test User');
      await git.addConfig('user.email', 'test@example.com');

      const emptyGctm = new GitCommitTimeMachine({ repoPath: emptyDir });

      const options = {
        startDate: '2023-01-01',
        endDate: '2023-01-05'
      };

      const result = await emptyGctm.redateCommits(options);

      expect(result.success).toBe(true);
      expect(result.message).toContain('No commits found');
      expect(result.processed).toBe(0);

      await fs.remove(emptyDir);
    });

    test('should preserve commit order when requested', async () => {
      // Create multiple commits
      const simpleGit = require('simple-git');
      const git = simpleGit({ baseDir: testRepoPath });

      for (let i = 2; i <= 5; i++) {
        await fs.writeFile(path.join(testRepoPath, `file${i}.txt`), `Content ${i}`);
        await git.add([`file${i}.txt`]);
        await git.commit(`Commit ${i}`);
      }

      const options = {
        startDate: '2023-01-01',
        endDate: '2023-01-05',
        preserveOrder: true,
        createBackup: false
      };

      const result = await gctm.redateCommits(options);

      expect(result.success).toBe(true);
      expect(result.processed).toBeGreaterThan(0);
    });
  });

  describe('Commit Message Editing', () => {
    test('should edit commit message successfully', async () => {
      const commits = await gctm.gitProcessor.getCommits();
      const commitHash = commits[0].hash;

      const options = {
        commitId: commitHash,
        newMessage: 'Updated: new commit message',
        createBackup: true
      };

      const result = await gctm.editCommitMessage(options);

      expect(result.success).toBe(true);

      // Verify the message was changed
      const updatedCommits = await gctm.gitProcessor.getCommits();
      expect(updatedCommits[0].message).toBe('Updated: new commit message');
    });

    test('should handle empty commit message', async () => {
      const commits = await gctm.gitProcessor.getCommits();
      const commitHash = commits[0].hash;

      const options = {
        commitId: commitHash,
        newMessage: '',
        createBackup: false
      };

      const result = await gctm.editCommitMessage(options);

      expect(result.success).toBe(false);
      expect(result.error).toBeDefined();
    });

    test('should handle invalid commit hash', async () => {
      const options = {
        commitId: 'invalid-hash',
        newMessage: 'New message',
        createBackup: false
      };

      const result = await gctm.editCommitMessage(options);

      expect(result.success).toBe(false);
      expect(result.error).toBeDefined();
    });
  });

  describe('Commit Content Editing', () => {
    test('should edit commit content successfully', async () => {
      const commits = await gctm.gitProcessor.getCommits();
      const commitHash = commits[0].hash;

      const options = {
        commitId: commitHash,
        replacements: [
          { pattern: 'Initial content', replacement: 'Modified content' }
        ],
        createBackup: true
      };

      const result = await gctm.editCommitContent(options);

      expect(result.success).toBe(true);
      expect(result.processedFiles).toBeGreaterThan(0);
    });

    test('should handle multiple replacements', async () => {
      const commits = await gctm.gitProcessor.getCommits();
      const commitHash = commits[0].hash;

      const options = {
        commitId: commitHash,
        replacements: [
          { pattern: 'Initial', replacement: 'Updated' },
          { pattern: 'content', replacement: 'data' }
        ],
        createBackup: false
      };

      const result = await gctm.editCommitContent(options);

      expect(result.success).toBe(true);
    });

    test('should handle regex replacements', async () => {
      const commits = await gctm.gitProcessor.getCommits();
      const commitHash = commits[0].hash;

      const options = {
        commitId: commitHash,
        replacements: [
          { pattern: /\w+ content/g, replacement: 'REPLACED' }
        ],
        createBackup: false
      };

      const result = await gctm.editCommitContent(options);

      expect(result.success).toBe(true);
    });
  });

  describe('History Sanitization', () => {
    test('should sanitize history successfully', async () => {
      // Create file with sensitive data
      await fs.writeFile(path.join(testRepoPath, 'config.env'), 'API_KEY=secret123\\nEMAIL=test@example.com');
      const simpleGit = require('simple-git');
      const git = simpleGit({ baseDir: testRepoPath });
      await git.add(['config.env']);
      await git.commit('Add config with sensitive data');

      const options = {
        patterns: ['secret123', 'test@example.com'],
        replacement: '***HIDDEN***',
        createBackup: true
      };

      const result = await gctm.sanitizeHistory(options);

      expect(result.success).toBe(true);
      expect(result.processed).toBeGreaterThan(0);
      expect(result.total).toBeGreaterThan(0);
    });

    test('should handle empty patterns array', async () => {
      const options = {
        patterns: [],
        replacement: '***HIDDEN***',
        createBackup: false
      };

      const result = await gctm.sanitizeHistory(options);

      expect(result.success).toBe(false);
      expect(result.error).toContain('At least one pattern must be specified');
    });

    test('should handle invalid patterns', async () => {
      const options = {
        patterns: [null, undefined, ''],
        replacement: '***HIDDEN***',
        createBackup: false
      };

      const result = await gctm.sanitizeHistory(options);

      expect(result.success).toBe(false);
    });
  });

  describe('Backup Management', () => {
    test('should list backups successfully', async () => {
      const backups = await gctm.listBackups();

      expect(Array.isArray(backups)).toBe(true);
    });

    test('should create and restore backup', async () => {
      // Create a backup
      const createResult = await gctm.backupManager.createBackup({
        description: 'Test backup for restoration'
      });

      expect(createResult.success).toBe(true);
      expect(createResult.backupId).toBeDefined();

      const backupId = createResult.backupId;

      // Restore the backup
      const restoreResult = await gctm.restoreBackup(backupId);

      expect(restoreResult.success).toBe(true);
    });

    test('should handle backup restoration failure', async () => {
      const result = await gctm.restoreBackup('nonexistent-backup-id');

      expect(result.success).toBe(false);
      expect(result.error).toBeDefined();
    });

    test('should handle backup listing errors', async () => {
      // Test with invalid repository path
      const invalidGctm = new GitCommitTimeMachine({
        repoPath: '/nonexistent/path'
      });

      const backups = await invalidGctm.listBackups();

      expect(Array.isArray(backups)).toBe(true);
      expect(backups.length).toBe(0);
    });
  });

  describe('AI Assistant Integration', () => {
    test('should initialize AI assistant', async () => {
      // Mock AI assistant initialization
      gctm.aiAssistant.initialize = jest.fn().mockResolvedValue({
        success: true,
        message: 'AI assistant initialized'
      });

      const result = await gctm.initializeAI();

      expect(result.success).toBe(true);
      expect(gctm.aiAssistant.initialize).toHaveBeenCalled();
    });

    test('should handle AI initialization failure', async () => {
      // Mock AI assistant initialization failure
      gctm.aiAssistant.initialize = jest.fn().mockResolvedValue({
        success: false,
        error: 'API key missing'
      });

      const result = await gctm.initializeAI();

      expect(result.success).toBe(false);
      expect(result.error).toContain('API key missing');
    });

    test('should generate AI commit message', async () => {
      // Mock git processor status
      gctm.gitProcessor.getStatus = jest.fn().mockResolvedValue({
        success: true,
        staged: ['test.txt'],
        modified: [],
        created: []
      });

      // Mock AI assistant
      gctm.aiAssistant.generateCommitMessage = jest.fn().mockResolvedValue({
        success: true,
        suggestions: ['feat: add new feature', 'fix: resolve issue']
      });

      const options = {
        language: 'en',
        style: 'conventional'
      };

      const result = await gctm.generateAICommitMessage(options);

      expect(result.success).toBe(true);
      expect(result.suggestions).toHaveLength(2);
      expect(result.suggestions[0]).toBe('feat: add new feature');
    });

    test('should handle git status errors in AI generation', async () => {
      // Mock git processor status failure
      gctm.gitProcessor.getStatus = jest.fn().mockResolvedValue({
        success: false,
        error: 'Not a git repository'
      });

      const options = {
        language: 'en',
        style: 'conventional'
      };

      const result = await gctm.generateAICommitMessage(options);

      expect(result.success).toBe(false);
      expect(result.error).toContain('Failed to get repository status');
    });

    test('should handle AI generation errors', async () => {
      // Mock git processor success
      gctm.gitProcessor.getStatus = jest.fn().mockResolvedValue({
        success: true,
        staged: ['test.txt'],
        modified: [],
        created: []
      });

      // Mock AI assistant failure
      gctm.aiAssistant.generateCommitMessage = jest.fn().mockResolvedValue({
        success: false,
        error: 'API request failed'
      });

      const options = {
        language: 'en',
        style: 'conventional'
      };

      const result = await gctm.generateAICommitMessage(options);

      expect(result.success).toBe(false);
      expect(result.error).toContain('API request failed');
    });

    test('should apply AI commit message', async () => {
      const message = 'feat: AI generated commit message';

      // Mock git processor
      gctm.gitProcessor.amendCommitMessage = jest.fn().mockResolvedValue({
        success: true
      });

      // Mock backup creation
      gctm.backupManager.createBackup = jest.fn().mockResolvedValue({
        success: true,
        backupId: 'test-backup-id'
      });

      const result = await gctm.applyAICommitMessage(message, true);

      expect(result.success).toBe(true);
      expect(result.message).toBe(message);
      expect(gctm.backupManager.createBackup).toHaveBeenCalled();
      expect(gctm.gitProcessor.amendCommitMessage).toHaveBeenCalledWith('HEAD', message);
    });

    test('should update AI configuration', async () => {
      const newConfig = {
        apiKey: 'new-api-key',
        model: 'gpt-4'
      };

      // Mock AI assistant
      gctm.aiAssistant.updateConfig = jest.fn().mockResolvedValue({
        success: true
      });

      const result = await gctm.updateAIConfig(newConfig);

      expect(result.success).toBe(true);
      expect(gctm.aiAssistant.updateConfig).toHaveBeenCalledWith(newConfig);
    });

    test('should test AI connection', async () => {
      // Mock AI assistant
      gctm.aiAssistant.testConnection = jest.fn().mockResolvedValue({
        success: true
      });

      const result = await gctm.testAIConnection();

      expect(result.success).toBe(true);
      expect(gctm.aiAssistant.testConnection).toHaveBeenCalled();
    });

    test('should get AI configuration', () => {
      // Mock AI assistant
      gctm.aiAssistant.getConfig = jest.fn().mockReturnValue({
        apiKey: 'test-key',
        model: 'gpt-3.5-turbo'
      });

      const config = gctm.getAIConfig();

      expect(config.apiKey).toBe('test-key');
      expect(config.model).toBe('gpt-3.5-turbo');
      expect(gctm.aiAssistant.getConfig).toHaveBeenCalled();
    });
  });

  describe('Error Handling', () => {
    test('should handle repository path errors', async () => {
      const invalidGctm = new GitCommitTimeMachine({
        repoPath: '/nonexistent/repository'
      });

      const result = await invalidGctm.redateCommits({
        startDate: '2023-01-01',
        endDate: '2023-01-05'
      });

      expect(result.success).toBe(false);
      expect(result.error).toBeDefined();
    });

    test('should handle git operation errors gracefully', async () => {
      // Mock git processor to throw error
      gctm.gitProcessor.getCommits = jest.fn().mockRejectedValue(new Error('Git operation failed'));

      const result = await gctm.redateCommits({
        startDate: '2023-01-01',
        endDate: '2023-01-05',
        createBackup: false
      });

      expect(result.success).toBe(false);
      expect(result.error).toContain('Redating operation failed');
    });

    test('should handle backup creation errors', async () => {
      // Mock backup manager to throw error
      gctm.backupManager.createBackup = jest.fn().mockRejectedValue(new Error('Backup failed'));

      const result = await gctm.redateCommits({
        startDate: '2023-01-01',
        endDate: '2023-01-05',
        createBackup: true
      });

      expect(result.success).toBe(false);
      expect(result.error).toBeDefined();
    });

    test('should handle date manager errors', async () => {
      // Mock date manager to throw error
      gctm.dateManager.generateDateRange = jest.fn().mockImplementation(() => {
        throw new Error('Date generation failed');
      });

      const result = await gctm.redateCommits({
        startDate: '2023-01-01',
        endDate: '2023-01-05',
        createBackup: false
      });

      expect(result.success).toBe(false);
      expect(result.error).toContain('Redating operation failed');
    });
  });

  describe('Integration Tests', () => {
    test('should complete full workflow with AI and operations', async () => {
      // 1. Initialize AI
      gctm.aiAssistant.initialize = jest.fn().mockResolvedValue({
        success: true
      });
      await gctm.initializeAI();

      // 2. Generate AI message
      gctm.gitProcessor.getStatus = jest.fn().mockResolvedValue({
        success: true,
        staged: ['test.txt'],
        modified: [],
        created: []
      });
      gctm.aiAssistant.generateCommitMessage = jest.fn().mockResolvedValue({
        success: true,
        suggestions: ['feat: implement new feature']
      });

      const aiResult = await gctm.generateAICommitMessage();
      expect(aiResult.success).toBe(true);

      // 3. Apply AI message
      gctm.gitProcessor.amendCommitMessage = jest.fn().mockResolvedValue({
        success: true
      });
      gctm.backupManager.createBackup = jest.fn().mockResolvedValue({
        success: true,
        backupId: 'test-backup'
      });

      const applyResult = await gctm.applyAICommitMessage(aiResult.suggestions[0]);
      expect(applyResult.success).toBe(true);

      // 4. Redate commits
      const redateResult = await gctm.redateCommits({
        startDate: '2023-01-01',
        endDate: '2023-01-05',
        createBackup: false
      });
      expect(redateResult.success).toBe(true);

      // 5. Sanitize history
      const sanitizeResult = await gctm.sanitizeHistory({
        patterns: ['sensitive-data'],
        replacement: '***HIDDEN***',
        createBackup: false
      });
      expect(sanitizeResult.success).toBe(true);
    });

    test('should handle operations without backup when specified', async () => {
      const commits = await gctm.gitProcessor.getCommits();
      const commitHash = commits[0].hash;

      // Operations with createBackup: false should not call backup manager
      gctm.backupManager.createBackup = jest.fn();

      const options = {
        commitId: commitHash,
        newMessage: 'Test message without backup',
        createBackup: false
      };

      await gctm.editCommitMessage(options);

      expect(gctm.backupManager.createBackup).not.toHaveBeenCalled();
    });

    test('should preserve operation defaults and consistency', async () => {
      // Test that createBackup defaults to true for destructive operations
      gctm.backupManager.createBackup = jest.fn().mockResolvedValue({
        success: true
      });

      // Call operation without specifying createBackup
      await gctm.editCommitMessage({
        commitId: (await gctm.gitProcessor.getCommits())[0].hash,
        newMessage: 'Default backup test'
      });

      // Backup should be created by default
      expect(gctm.backupManager.createBackup).toHaveBeenCalled();
    });
  });
});