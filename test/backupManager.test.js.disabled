/**
 * Backup Manager - Comprehensive Tests
 */

const BackupManager = require('../src/backupManager');
const fs = require('fs-extra');
const path = require('path');
const os = require('os');

describe('BackupManager', () => {
  let backupManager;
  let testRepoPath;
  let backupDir;

  beforeEach(async () => {
    // Create temporary test directory
    testRepoPath = await fs.mkdtemp(path.join(os.tmpdir(), 'gctm-backup-test-'));

    // Initialize git repo
    const simpleGit = require('simple-git');
    const git = simpleGit({ baseDir: testRepoPath });
    await git.init();
    await git.addConfig('user.name', 'Test User');
    await git.addConfig('user.email', 'test@example.com');
    await git.addConfig('commit.gpgsign', 'false');

    // Create test commits
    await fs.writeFile(path.join(testRepoPath, 'file1.txt'), 'Content 1');
    await git.add(['file1.txt']);
    await git.commit('Initial commit');

    await fs.writeFile(path.join(testRepoPath, 'file2.txt'), 'Content 2');
    await git.add(['file2.txt']);
    await git.commit('Second commit');

    // Create backup directory
    backupDir = await fs.mkdtemp(path.join(os.tmpdir(), 'gctm-backups-'));

    backupManager = new BackupManager(testRepoPath, {
      backupDir: backupDir,
      maxBackups: 5
    });
  });

  afterEach(async () => {
    await fs.remove(testRepoPath);
    await fs.remove(backupDir);
  });

  describe('Constructor', () => {
    test('should create instance with default options', () => {
      const manager = new BackupManager(testRepoPath);
      expect(manager.repoPath).toBe(testRepoPath);
      expect(manager.backupDir).toBeDefined();
      expect(manager.maxBackups).toBe(10); // Default value
    });

    test('should create instance with custom options', () => {
      const options = {
        backupDir: backupDir,
        maxBackups: 15,
        compressionLevel: 6
      };

      const manager = new BackupManager(testRepoPath, options);
      expect(manager.repoPath).toBe(testRepoPath);
      expect(manager.backupDir).toBe(backupDir);
      expect(manager.maxBackups).toBe(15);
      expect(manager.compressionLevel).toBe(6);
    });

    test('should create default backup directory if not specified', () => {
      const manager = new BackupManager(testRepoPath);
      const expectedBackupDir = path.join(testRepoPath, '.gctm', 'backups');
      expect(manager.backupDir).toBe(expectedBackupDir);
    });
  });

  describe('Backup Creation', () => {
    test('should create backup successfully', async () => {
      const result = await backupManager.createBackup();

      expect(result.success).toBe(true);
      expect(result.backupId).toBeDefined();
      expect(result.metadata).toBeDefined();
      expect(typeof result.backupId).toBe('string');
      expect(result.backupId.length).toBeGreaterThan(0);
    });

    test('should create backup with description', async () => {
      const options = {
        description: 'Test backup description'
      };

      const result = await backupManager.createBackup(options);

      expect(result.success).toBe(true);
      expect(result.metadata.description).toBe('Test backup description');
    });

    test('should include uncommitted changes when requested', async () => {
      // Create uncommitted changes
      await fs.writeFile(path.join(testRepoPath, 'uncommitted.txt'), 'Uncommitted content');

      const options = {
        includeUncommitted: true
      };

      const result = await backupManager.createBackup(options);

      expect(result.success).toBe(true);
      expect(result.metadata.hasUncommittedChanges).toBe(true);
    });

    test('should handle backup without uncommitted changes', async () => {
      const options = {
        includeUncommitted: false
      };

      const result = await backupManager.createBackup(options);

      expect(result.success).toBe(true);
      expect(result.metadata.hasUncommittedChanges).toBe(false);
    });

    test('should include branch information in backup metadata', async () => {
      const result = await backupManager.createBackup();

      expect(result.success).toBe(true);
      expect(result.metadata.currentBranch).toBeDefined();
      expect(typeof result.metadata.currentBranch).toBe('string');
    });

    test('should include commit information in backup metadata', async () => {
      const result = await backupManager.createBackup();

      expect(result.success).toBe(true);
      expect(result.metadata.totalCommits).toBeDefined();
      expect(typeof result.metadata.totalCommits).toBe('number');
      expect(result.metadata.totalCommits).toBeGreaterThan(0);
    });

    test('should handle backup creation errors gracefully', async () => {
      // Test with invalid repository path
      const invalidManager = new BackupManager('/nonexistent/path');

      const result = await invalidManager.createBackup();

      expect(result.success).toBe(false);
      expect(result.error).toBeDefined();
    });

    test('should handle file system errors during backup', async () => {
      // Create backup manager with read-only directory
      const readOnlyDir = await fs.mkdtemp(path.join(os.tmpdir(), 'readonly-backup-'));
      try {
        await fs.chmod(readOnlyDir, 0o444); // Read-only

        const readOnlyManager = new BackupManager(testRepoPath, {
          backupDir: path.join(readOnlyDir, 'backups')
        });

        const result = await readOnlyManager.createBackup();

        expect(result.success).toBe(false);
        expect(result.error).toBeDefined();
      } finally {
        await fs.chmod(readOnlyDir, 0o755); // Restore permissions
        await fs.remove(readOnlyDir);
      }
    });
  });

  describe('Backup Listing', () => {
    test('should list available backups', async () => {
      // Create some backups first
      await backupManager.createBackup({ description: 'Backup 1' });
      await backupManager.createBackup({ description: 'Backup 2' });

      const backups = await backupManager.listBackups();

      expect(Array.isArray(backups)).toBe(true);
      expect(backups.length).toBeGreaterThanOrEqual(2);

      // Check structure of backup objects
      backups.forEach(backup => {
        expect(backup).toHaveProperty('id');
        expect(backup).toHaveProperty('createdAt');
        expect(backup).toHaveProperty('description');
        expect(backup).toHaveProperty('size');
        expect(backup).toHaveProperty('metadata');
        expect(typeof backup.id).toBe('string');
        expect(typeof backup.createdAt).toBe('string');
        expect(typeof backup.size).toBe('number');
      });
    });

    test('should return empty array when no backups exist', async () => {
      const backups = await backupManager.listBackups();

      expect(Array.isArray(backups)).toBe(true);
      expect(backups.length).toBe(0);
    });

    test('should handle corrupted backup files gracefully', async () => {
      // Create a backup first
      await backupManager.createBackup({ description: 'Valid backup' });

      // Corrupt a backup file
      const backups = await backupManager.listBackups();
      if (backups.length > 0) {
        const backupFilePath = path.join(backupDir, `${backups[0].id}.json`);
        await fs.writeFile(backupFilePath, 'invalid json content');

        // Listing should still work and ignore corrupted files
        const updatedBackups = await backupManager.listBackups();
        expect(Array.isArray(updatedBackups)).toBe(true);
      }
    });

    test('should sort backups by creation date (newest first)', async () => {
      // Create backups with delays to ensure different timestamps
      await backupManager.createBackup({ description: 'First backup' });
      await new Promise(resolve => setTimeout(resolve, 100));
      await backupManager.createBackup({ description: 'Second backup' });
      await new Promise(resolve => setTimeout(resolve, 100));
      await backupManager.createBackup({ description: 'Third backup' });

      const backups = await backupManager.listBackups();

      expect(backups.length).toBeGreaterThanOrEqual(3);

      // Verify sorting (newest first)
      for (let i = 0; i < backups.length - 1; i++) {
        const currentDate = new Date(backups[i].createdAt);
        const nextDate = new Date(backups[i + 1].createdAt);
        expect(currentDate.getTime()).toBeGreaterThanOrEqual(nextDate.getTime());
      }
    });
  });

  describe('Backup Restoration', () => {
    test('should restore backup successfully', async () => {
      // Create backup
      const createResult = await backupManager.createBackup({
        description: 'Backup for restoration test'
      });
      expect(createResult.success).toBe(true);

      // Make some changes to the repository
      const simpleGit = require('simple-git');
      const git = simpleGit({ baseDir: testRepoPath });
      await fs.writeFile(path.join(testRepoPath, 'new-file.txt'), 'New content');
      await git.add(['new-file.txt']);
      await git.commit('New commit after backup');

      // Restore from backup
      const restoreResult = await backupManager.restoreBackup(createResult.backupId);

      expect(restoreResult.success).toBe(true);
      expect(restoreResult.backupId).toBe(createResult.backupId);
    });

    test('should handle restoration of non-existent backup', async () => {
      const result = await backupManager.restoreBackup('nonexistent-backup-id');

      expect(result.success).toBe(false);
      expect(result.error).toContain('not found');
    });

    test('should verify backup integrity before restoration', async () => {
      // Create backup
      const createResult = await backupManager.createBackup();
      expect(createResult.success).toBe(true);

      // Modify backup file to corrupt it
      const backupFilePath = path.join(backupDir, `${createResult.backupId}.json`);
      const backupData = await fs.readJson(backupFilePath);
      backupData.metadata.totalCommits = 999; // Corrupt the data
      await fs.writeJson(backupFilePath, backupData);

      // Try to restore
      const restoreResult = await backupManager.restoreBackup(createResult.backupId);

      expect(restoreResult.success).toBe(false);
      expect(restoreResult.error).toBeDefined();
    });

    test('should handle restoration errors gracefully', async () => {
      // Test with invalid repository path
      const invalidManager = new BackupManager('/nonexistent/path', {
        backupDir: backupDir
      });

      const result = await invalidManager.restoreBackup('any-backup-id');

      expect(result.success).toBe(false);
      expect(result.error).toBeDefined();
    });
  });

  describe('Backup Deletion', () => {
    test('should delete backup successfully', async () => {
      // Create backup
      const createResult = await backupManager.createBackup();
      expect(createResult.success).toBe(true);

      // Verify backup exists
      const backupsBefore = await backupManager.listBackups();
      expect(backupsBefore.some(b => b.id === createResult.backupId)).toBe(true);

      // Delete backup
      const deleteResult = await backupManager.deleteBackup(createResult.backupId);

      expect(deleteResult.success).toBe(true);
      expect(deleteResult.backupId).toBe(createResult.backupId);

      // Verify backup is deleted
      const backupsAfter = await backupManager.listBackups();
      expect(backupsAfter.some(b => b.id === createResult.backupId)).toBe(false);
    });

    test('should handle deletion of non-existent backup', async () => {
      const result = await backupManager.deleteBackup('nonexistent-backup-id');

      expect(result.success).toBe(false);
      expect(result.error).toContain('not found');
    });

    test('should clean up backup files when deleting backup', async () => {
      // Create backup
      const createResult = await backupManager.createBackup();
      expect(createResult.success).toBe(true);

      // Check that backup files exist
      const metadataFile = path.join(backupDir, `${createResult.backupId}.json`);
      const backupFile = path.join(backupDir, `${createResult.backupId}.tar.gz`);

      expect(await fs.pathExists(metadataFile)).toBe(true);
      expect(await fs.pathExists(backupFile)).toBe(true);

      // Delete backup
      await backupManager.deleteBackup(createResult.backupId);

      // Check that backup files are deleted
      expect(await fs.pathExists(metadataFile)).toBe(false);
      expect(await fs.pathExists(backupFile)).toBe(false);
    });
  });

  describe('Backup Cleanup and Maintenance', () => {
    test('should cleanup old backups when maxBackups exceeded', async () => {
      // Create more backups than maxBackups limit (maxBackups = 5 in beforeEach)
      const backupIds = [];
      for (let i = 0; i < 8; i++) {
        const result = await backupManager.createBackup({
          description: `Backup ${i + 1}`
        });
        backupIds.push(result.backupId);

        // Add small delay to ensure different timestamps
        await new Promise(resolve => setTimeout(resolve, 50));
      }

      const backups = await backupManager.listBackups();
      expect(backups.length).toBeLessThanOrEqual(5); // Should not exceed maxBackups

      // Verify that newest backups are kept
      const sortedBackupIds = backups.map(b => b.id).reverse(); // Oldest first
      expect(sortedBackupIds).not.toContain(backupIds[0]); // Oldest should be deleted
      expect(sortedBackupIds).toContain(backupIds[backupIds.length - 1]); // Newest should be kept
    });

    test('should cleanup corrupted backup files', async () => {
      // Create some valid backups
      await backupManager.createBackup({ description: 'Valid 1' });
      await backupManager.createBackup({ description: 'Valid 2' });

      // Create corrupted backup files
      await fs.writeFile(path.join(backupDir, 'corrupted1.json'), 'invalid json');
      await fs.writeFile(path.join(backupDir, 'corrupted2.json'), 'more invalid json');
      await fs.writeFile(path.join(backupDir, 'orphan-file.txt'), 'orphan content');

      // Run cleanup
      await backupManager.cleanup();

      // Check that corrupted files are removed
      expect(await fs.pathExists(path.join(backupDir, 'corrupted1.json'))).toBe(false);
      expect(await fs.pathExists(path.join(backupDir, 'corrupted2.json'))).toBe(false);
      expect(await fs.pathExists(path.join(backupDir, 'orphan-file.txt'))).toBe(false);

      // Valid backups should still exist
      const backups = await backupManager.listBackups();
      expect(backups.length).toBeGreaterThanOrEqual(2);
    });

    test('should calculate backup size correctly', async () => {
      const result = await backupManager.createBackup();
      expect(result.success).toBe(true);

      const backups = await backupManager.listBackups();
      const backup = backups.find(b => b.id === result.backupId);
      expect(backup).toBeDefined();
      expect(backup.size).toBeGreaterThan(0);
    });

    test('should handle cleanup when no backups exist', async () => {
      expect(() => {
        backupManager.cleanup();
      }).not.toThrow();
    });
  });

  describe('Backup Validation', () => {
    test('should validate backup format and structure', async () => {
      const result = await backupManager.createBackup();
      expect(result.success).toBe(true);

      const isValid = await backupManager.validateBackup(result.backupId);

      expect(isValid).toBe(true);
    });

    test('should detect invalid backup format', async () => {
      // Create invalid backup file
      const invalidBackupId = 'invalid-backup';
      await fs.writeJson(path.join(backupDir, `${invalidBackupId}.json`), {
        invalid: 'structure'
      });

      const isValid = await backupManager.validateBackup(invalidBackupId);

      expect(isValid).toBe(false);
    });

    test('should detect missing backup files', async () => {
      // Create backup metadata but missing archive file
      const backupId = 'missing-files-backup';
      await fs.writeJson(path.join(backupDir, `${backupId}.json`), {
        id: backupId,
        metadata: { totalCommits: 1 },
        createdAt: new Date().toISOString()
      });

      const isValid = await backupManager.validateBackup(backupId);

      expect(isValid).toBe(false);
    });

    test('should handle validation of non-existent backup', async () => {
      const isValid = await backupManager.validateBackup('nonexistent-backup');

      expect(isValid).toBe(false);
    });
  });

  describe('Backup Statistics', () => {
    test('should provide backup statistics', async () => {
      // Create some backups
      await backupManager.createBackup({ description: 'Stats backup 1' });
      await backupManager.createBackup({ description: 'Stats backup 2' });

      const stats = await backupManager.getStatistics();

      expect(stats).toHaveProperty('totalBackups');
      expect(stats).toHaveProperty('totalSize');
      expect(stats).toHaveProperty('oldestBackup');
      expect(stats).toHaveProperty('newestBackup');
      expect(stats).toHaveProperty('averageBackupSize');

      expect(stats.totalBackups).toBeGreaterThanOrEqual(2);
      expect(stats.totalSize).toBeGreaterThan(0);
      expect(stats.averageBackupSize).toBeGreaterThan(0);
    });

    test('should handle statistics when no backups exist', async () => {
      const stats = await backupManager.getStatistics();

      expect(stats.totalBackups).toBe(0);
      expect(stats.totalSize).toBe(0);
      expect(stats.oldestBackup).toBeNull();
      expect(stats.newestBackup).toBeNull();
      expect(stats.averageBackupSize).toBe(0);
    });

    test('should calculate backup size distribution', async () => {
      // Create backups of different sizes
      await backupManager.createBackup({ description: 'Small backup' });

      // Create more files for larger backup
      await fs.writeFile(path.join(testRepoPath, 'large-file.txt'), 'x'.repeat(10000));
      const simpleGit = require('simple-git');
      const git = simpleGit({ baseDir: testRepoPath });
      await git.add(['large-file.txt']);
      await git.commit('Add large file');

      await backupManager.createBackup({ description: 'Large backup' });

      const distribution = await backupManager.getSizeDistribution();

      expect(Array.isArray(distribution)).toBe(true);
      expect(distribution.length).toBeGreaterThanOrEqual(2);

      distribution.forEach(bucket => {
        expect(bucket).toHaveProperty('range');
        expect(bucket).toHaveProperty('count');
        expect(bucket).toHaveProperty('totalSize');
      });
    });
  });

  describe('Error Handling', () => {
    test('should handle git operation errors during backup', async () => {
      // Test with corrupted repository
      await fs.remove(path.join(testRepoPath, '.git'));

      const result = await backupManager.createBackup();

      expect(result.success).toBe(false);
      expect(result.error).toBeDefined();
    });

    test('should handle permission errors', async () => {
      // Make backup directory read-only
      await fs.chmod(backupDir, 0o444);

      const result = await backupManager.createBackup();

      expect(result.success).toBe(false);

      // Restore permissions for cleanup
      await fs.chmod(backupDir, 0o755);
    });

    test('should handle disk space issues', async () => {
      // Mock low disk space by setting a very small size limit
      backupManager.maxBackupSize = 100; // 100 bytes

      const result = await backupManager.createBackup();

      expect(result.success).toBe(false);
      expect(result.error).toBeDefined();
    });

    test('should handle concurrent backup operations', async () => {
      const promises = [];
      for (let i = 0; i < 5; i++) {
        promises.push(backupManager.createBackup({
          description: `Concurrent backup ${i}`
        }));
      }

      const results = await Promise.allSettled(promises);

      // All operations should complete without throwing
      results.forEach(result => {
        expect(result.status).toBe('fulfilled');
        if (result.status === 'fulfilled') {
          expect(result.value).toHaveProperty('success');
        }
      });

      // At least some backups should succeed
      const successful = results.filter(r =>
        r.status === 'fulfilled' && r.value.success
      );
      expect(successful.length).toBeGreaterThan(0);
    });
  });

  describe('Integration Tests', () => {
    test('should complete full backup lifecycle', async () => {
      // 1. Create initial backup
      const backup1 = await backupManager.createBackup({
        description: 'Initial state'
      });
      expect(backup1.success).toBe(true);

      // 2. Make changes to repository
      const simpleGit = require('simple-git');
      const git = simpleGit({ baseDir: testRepoPath });
      await fs.writeFile(path.join(testRepoPath, 'change.txt'), 'Some change');
      await git.add(['change.txt']);
      await git.commit('Make some changes');

      // 3. Create second backup
      const backup2 = await backupManager.createBackup({
        description: 'After changes'
      });
      expect(backup2.success).toBe(true);

      // 4. List backups
      const backups = await backupManager.listBackups();
      expect(backups.length).toBeGreaterThanOrEqual(2);

      // 5. Validate both backups
      const valid1 = await backupManager.validateBackup(backup1.backupId);
      const valid2 = await backupManager.validateBackup(backup2.backupId);
      expect(valid1).toBe(true);
      expect(valid2).toBe(true);

      // 6. Restore first backup
      const restore = await backupManager.restoreBackup(backup1.backupId);
      expect(restore.success).toBe(true);

      // 7. Delete second backup
      const deleteResult = await backupManager.deleteBackup(backup2.backupId);
      expect(deleteResult.success).toBe(true);

      // 8. Verify only first backup remains
      const finalBackups = await backupManager.listBackups();
      expect(finalBackups.length).toBe(1);
      expect(finalBackups[0].id).toBe(backup1.backupId);
    });

    test('should work with large repositories', async () => {
      // Create many files and commits
      const simpleGit = require('simple-git');
      const git = simpleGit({ baseDir: testRepoPath });

      for (let i = 0; i < 10; i++) {
        await fs.writeFile(path.join(testRepoPath, `file${i}.txt`), `Content ${i}\n${'x'.repeat(1000)}`);
        await git.add([`file${i}.txt`]);
        await git.commit(`Add file ${i}`);
      }

      // Create backup of large repository
      const result = await backupManager.createBackup({
        description: 'Large repository backup'
      });

      expect(result.success).toBe(true);
      expect(result.metadata.totalCommits).toBeGreaterThan(10);

      // Restore and verify
      const restore = await backupManager.restoreBackup(result.backupId);
      expect(restore.success).toBe(true);
    });
  });
});