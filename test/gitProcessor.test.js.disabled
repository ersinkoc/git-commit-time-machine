/**
 * Git Processor - Comprehensive Tests
 */

const GitProcessor = require('../src/gitProcessor');
const fs = require('fs-extra');
const path = require('path');
const os = require('os');

describe('GitProcessor', () => {
  let gitProcessor;
  let testRepoPath;
  let git;

  beforeEach(async () => {
    // Create temporary test directory
    testRepoPath = await fs.mkdtemp(path.join(os.tmpdir(), 'gctm-processor-test-'));

    // Initialize git repo
    const simpleGit = require('simple-git');
    git = simpleGit({ baseDir: testRepoPath });
    await git.init();
    await git.addConfig('user.name', 'Test User');
    await git.addConfig('user.email', 'test@example.com');
    await git.addConfig('commit.gpgsign', 'false');

    // Create test commits
    await fs.writeFile(path.join(testRepoPath, 'file1.txt'), 'Content 1');
    await git.add(['file1.txt']);
    await git.commit('Initial commit');

    await fs.writeFile(path.join(testRepoPath, 'file2.txt'), 'Content 2');
    await git.add(['file2.txt']);
    await git.commit('Second commit');

    gitProcessor = new GitProcessor(testRepoPath);
  });

  afterEach(async () => {
    await fs.remove(testRepoPath);
  });

  describe('Constructor', () => {
    test('should create instance with repo path', () => {
      const processor = new GitProcessor(testRepoPath);
      expect(processor.repoPath).toBe(testRepoPath);
      expect(processor.git).toBeDefined();
    });

    test('should handle missing repo path', () => {
      expect(() => {
        new GitProcessor('');
      }).toThrow('Repository path is required');
    });

    test('should handle non-existent directory', () => {
      expect(() => {
        new GitProcessor('/non/existent/path');
      }).toThrow('Repository directory does not exist');
    });
  });

  describe('Repository Validation', () => {
    test('should validate git repository', async () => {
      const isGitRepo = await gitProcessor.isGitRepo();
      expect(isGitRepo).toBe(true);
    });

    test('should handle non-git directory', async () => {
      const nonGitDir = await fs.mkdtemp(path.join(os.tmpdir(), 'non-git-'));
      const processor = new GitProcessor(nonGitDir);

      const isGitRepo = await processor.isGitRepo();
      expect(isGitRepo).toBe(false);

      await fs.remove(nonGitDir);
    });
  });

  describe('Commit Operations', () => {
    test('should get commits', async () => {
      const commits = await gitProcessor.getCommits();
      expect(commits).toHaveLength(2);
      expect(commits[0]).toHaveProperty('hash');
      expect(commits[0]).toHaveProperty('message');
      expect(commits[0]).toHaveProperty('author');
      expect(commits[0]).toHaveProperty('date');
      expect(commits[0]).toHaveProperty('shortHash');
    });

    test('should get commits with limit', async () => {
      const commits = await gitProcessor.getCommits({ limit: 1 });
      expect(commits).toHaveLength(1);
    });

    test('should get commits with date range', async () => {
      const commits = await gitProcessor.getCommits({
        since: '2020-01-01',
        until: '2030-01-01'
      });
      expect(commits.length).toBeGreaterThan(0);
    });

    test('should get commits with filter', async () => {
      const filter = jest.fn((commit) => commit.message.includes('Initial'));
      const commits = await gitProcessor.getCommits({ filter });
      expect(filter).toHaveBeenCalled();
    });

    test('should get single commit', async () => {
      const commits = await gitProcessor.getCommits();
      const commitHash = commits[0].hash;

      const commit = await gitProcessor.getCommit(commitHash);
      expect(commit.success).toBe(true);
      expect(commit.commit).toHaveProperty('hash');
      expect(commit.commit.hash).toBe(commitHash);
    });

    test('should handle non-existent commit', async () => {
      const commit = await gitProcessor.getCommit('nonexistent');
      expect(commit.success).toBe(false);
      expect(commit.error).toBeDefined();
    });

    test('should get commit files', async () => {
      const files = await gitProcessor.getCommitFiles('HEAD');
      expect(files.success).toBe(true);
      expect(Array.isArray(files.files)).toBe(true);
    });

    test('should get commit diff', async () => {
      const diff = await gitProcessor.getCommitDiff('HEAD');
      expect(diff.success).toBe(true);
      expect(diff.diff).toBeDefined();
    });

    test('should handle diff errors gracefully', async () => {
      const diff = await gitProcessor.getCommitDiff('nonexistent');
      expect(diff.success).toBe(false);
      expect(diff.error).toBeDefined();
    });
  });

  describe('Status Operations', () => {
    test('should get repository status', async () => {
      const status = await gitProcessor.getStatus();
      expect(status.success).toBe(true);
      expect(status).toHaveProperty('staged');
      expect(status).toHaveProperty('modified');
      expect(status).toHaveProperty('created');
      expect(status).toHaveProperty('deleted');
      expect(Array.isArray(status.staged)).toBe(true);
      expect(Array.isArray(status.modified)).toBe(true);
      expect(Array.isArray(status.created)).toBe(true);
      expect(Array.isArray(status.deleted)).toBe(true);
    });

    test('should detect working directory changes', async () => {
      // Create uncommitted changes
      await fs.writeFile(path.join(testRepoPath, 'uncommitted.txt'), 'Uncommitted content');

      const status = await gitProcessor.getStatus();
      expect(status.success).toBe(true);
      expect(status.hasChanges).toBe(true);
    });

    test('should detect staged changes', async () => {
      // Create and stage changes
      await fs.writeFile(path.join(testRepoPath, 'staged.txt'), 'Staged content');
      await git.add(['staged.txt']);

      const status = await gitProcessor.getStatus();
      expect(status.success).toBe(true);
      expect(status.staged.length).toBeGreaterThan(0);
    });

    test('should detect clean working directory', async () => {
      const status = await gitProcessor.getStatus();
      expect(status.success).toBe(true);
      expect(status.isClean).toBe(true);
    });
  });

  describe('Commit Message Operations', () => {
    test('should amend commit message', async () => {
      const commits = await gitProcessor.getCommits();
      const commitHash = commits[0].hash;
      const newMessage = 'Updated commit message';

      const result = await gitProcessor.amendCommitMessage(commitHash, newMessage);

      expect(result.success).toBe(true);
      expect(result.hash).toBe(commitHash);

      // Verify the message was changed
      const updatedCommits = await gitProcessor.getCommits();
      expect(updatedCommits[0].message).toBe(newMessage);
    });

    test('should handle empty commit message', async () => {
      const commits = await gitProcessor.getCommits();
      const commitHash = commits[0].hash;

      const result = await gitProcessor.amendCommitMessage(commitHash, '');

      expect(result.success).toBe(false);
      expect(result.error).toBeDefined();
    });

    test('should handle invalid commit hash', async () => {
      const result = await gitProcessor.amendCommitMessage('invalid-hash', 'New message');

      expect(result.success).toBe(false);
      expect(result.error).toBeDefined();
    });
  });

  describe('Content Replacement Operations', () => {
    test('should replace content in commit history', async () => {
      const commits = await gitProcessor.getCommits();
      const commitHash = commits[0].hash;

      const replacements = [
        { pattern: 'Content 1', replacement: 'Modified Content 1' }
      ];

      const result = await gitProcessor.replaceContentInHistory(replacements, commitHash);

      expect(result.success).toBe(true);
      expect(result.processedFiles).toBeGreaterThan(0);
    });

    test('should handle multiple replacements', async () => {
      const commits = await gitProcessor.getCommits();
      const commitHash = commits[0].hash;

      const replacements = [
        { pattern: 'Content 1', replacement: 'New Content 1' },
        { pattern: 'Content 2', replacement: 'New Content 2' }
      ];

      const result = await gitProcessor.replaceContentInHistory(replacements, commitHash);

      expect(result.success).toBe(true);
    });

    test('should handle regex replacements', async () => {
      const commits = await gitProcessor.getCommits();
      const commitHash = commits[0].hash;

      const replacements = [
        { pattern: /Content \d+/g, replacement: 'Replaced Content' }
      ];

      const result = await gitProcessor.replaceContentInHistory(replacements, commitHash);

      expect(result.success).toBe(true);
    });

    test('should handle non-matching patterns', async () => {
      const commits = await gitProcessor.getCommits();
      const commitHash = commits[0].hash;

      const replacements = [
        { pattern: 'NonExistentPattern', replacement: 'Something' }
      ];

      const result = await gitProcessor.replaceContentInHistory(replacements, commitHash);

      expect(result.success).toBe(true);
      expect(result.processedFiles).toBe(0);
    });
  });

  describe('Date Modification Operations', () => {
    test('should amend single commit date', async () => {
      const commits = await gitProcessor.getCommits();
      const commitHash = commits[0].hash;
      const newDate = '2023-01-01T12:00:00';

      const result = await gitProcessor.amendCommitDate(commitHash, newDate);

      expect(result.success).toBe(true);
      expect(result.hash).toBe(commitHash);
    });

    test('should handle invalid date format', async () => {
      const commits = await gitProcessor.getCommits();
      const commitHash = commits[0].hash;

      const result = await gitProcessor.amendCommitDate(commitHash, 'invalid-date');

      expect(result.success).toBe(false);
      expect(result.error).toBeDefined();
    });

    test('should amend multiple commit dates', async () => {
      const commits = await gitProcessor.getCommits();
      const commitsWithDates = commits.map((commit, index) => ({
        hash: commit.hash,
        newDate: `2023-01-0${index + 1}T12:00:00`
      }));

      const result = await gitProcessor.amendMultipleCommitDates(commitsWithDates);

      expect(result.success).toBe(true);
      expect(result.processed).toBe(commits.length);
    });

    test('should handle empty commits list for date amendment', async () => {
      const result = await gitProcessor.amendMultipleCommitDates([]);

      expect(result.success).toBe(true);
      expect(result.processed).toBe(0);
    });

    test('should validate commit date format', async () => {
      const validDate = gitProcessor.isValidCommitDate('2023-01-01T12:00:00');
      expect(validDate).toBe(true);

      const invalidDate = gitProcessor.isValidCommitDate('invalid-date');
      expect(invalidDate).toBe(false);

      const emptyDate = gitProcessor.isValidCommitDate('');
      expect(emptyDate).toBe(false);
    });
  });

  describe('Branch Operations', () => {
    test('should get current branch', async () => {
      const branch = await gitProcessor.getCurrentBranch();

      expect(branch.success).toBe(true);
      expect(branch.branch).toBeDefined();
      expect(typeof branch.branch).toBe('string');
    });

    test('should get all branches', async () => {
      const branches = await gitProcessor.getBranches();

      expect(branches.success).toBe(true);
      expect(Array.isArray(branches.branches)).toBe(true);
      expect(branches.branches.length).toBeGreaterThan(0);

      // Check structure
      branches.branches.forEach(branch => {
        expect(branch).toHaveProperty('name');
        expect(branch).toHaveProperty('current');
        expect(typeof branch.current).toBe('boolean');
      });
    });

    test('should create and switch branches', async () => {
      // Create new branch
      const createResult = await gitProcessor.createBranch('test-feature');

      expect(createResult.success).toBe(true);

      // Switch to new branch
      const switchResult = await gitProcessor.switchBranch('test-feature');

      expect(switchResult.success).toBe(true);

      // Verify current branch
      const currentBranch = await gitProcessor.getCurrentBranch();
      expect(currentBranch.branch).toBe('test-feature');
    });

    test('should handle branch creation errors', async () => {
      const result = await gitProcessor.createBranch(''); // Empty branch name

      expect(result.success).toBe(false);
      expect(result.error).toBeDefined();
    });

    test('should handle branch switching errors', async () => {
      const result = await gitProcessor.switchBranch('nonexistent-branch');

      expect(result.success).toBe(false);
      expect(result.error).toBeDefined();
    });
  });

  describe('Tag Operations', () => {
    test('should create tag', async () => {
      const commits = await gitProcessor.getCommits();
      const commitHash = commits[0].hash;

      const result = await gitProcessor.createTag('v1.0.0', commitHash, 'Version 1.0.0');

      expect(result.success).toBe(true);
    });

    test('should get tags', async () => {
      // Create a test tag first
      await git.createTag('test-tag', '-m', 'Test tag');

      const tags = await gitProcessor.getTags();

      expect(tags.success).toBe(true);
      expect(Array.isArray(tags.tags)).toBe(true);
    });

    test('should handle tag creation errors', async () => {
      const result = await gitProcessor.createTag('', 'HEAD', 'Invalid tag');

      expect(result.success).toBe(false);
      expect(result.error).toBeDefined();
    });
  });

  describe('Remote Operations', () => {
    test('should get remotes', async () => {
      const remotes = await gitProcessor.getRemotes();

      expect(remotes.success).toBe(true);
      expect(Array.isArray(remotes.remotes)).toBe(true);

      // Check structure
      remotes.remotes.forEach(remote => {
        expect(remote).toHaveProperty('name');
        expect(remote).toHaveProperty('fetchUrl');
        expect(remote).toHaveProperty('pushUrl');
      });
    });

    test('should add remote', async () => {
      const result = await gitProcessor.addRemote('test-origin', 'https://github.com/test/repo.git');

      expect(result.success).toBe(true);
    });

    test('should handle remote addition errors', async () => {
      const result = await gitProcessor.addRemote('', 'invalid-url');

      expect(result.success).toBe(false);
      expect(result.error).toBeDefined();
    });
  });

  describe('Stash Operations', () => {
    test('should create stash', async () => {
      // Create some uncommitted changes
      await fs.writeFile(path.join(testRepoPath, 'stash-test.txt'), 'Stash content');

      const result = await gitProcessor.createStash('Test stash message');

      expect(result.success).toBe(true);
    });

    test('should get stash list', async () => {
      // Create a stash first
      await fs.writeFile(path.join(testRepoPath, 'stash-test.txt'), 'Stash content');
      await gitProcessor.createStash('Test stash');

      const stashes = await gitProcessor.getStashes();

      expect(stashes.success).toBe(true);
      expect(Array.isArray(stashes.stashes)).toBe(true);
    });

    test('should apply stash', async () => {
      // Create and apply stash
      await fs.writeFile(path.join(testRepoPath, 'stash-apply.txt'), 'Content to stash');
      await gitProcessor.createStash('Test apply stash');

      const result = await gitProcessor.applyStash(0);

      expect(result.success).toBe(true);
    });

    test('should handle stash operations with no changes', async () => {
      const result = await gitProcessor.createStash('Empty stash');

      expect(result.success).toBe(false);
      expect(result.error).toBeDefined();
    });
  });

  describe('Reset and Revert Operations', () => {
    test('should reset to commit', async () => {
      const commits = await gitProcessor.getCommits();
      const targetCommit = commits[commits.length - 1].hash; // Reset to first commit

      const result = await gitProcessor.resetToCommit(targetCommit, 'soft');

      expect(result.success).toBe(true);
    });

    test('should revert commit', async () => {
      const commits = await gitProcessor.getCommits();
      const commitToRevert = commits[0].hash;

      const result = await gitProcessor.revertCommit(commitToRevert);

      expect(result.success).toBe(true);
    });

    test('should handle reset with invalid mode', async () => {
      const commits = await gitProcessor.getCommits();
      const targetCommit = commits[0].hash;

      const result = await gitProcessor.resetToCommit(targetCommit, 'invalid-mode');

      expect(result.success).toBe(false);
      expect(result.error).toBeDefined();
    });

    test('should handle revert errors', async () => {
      const result = await gitProcessor.revertCommit('nonexistent');

      expect(result.success).toBe(false);
      expect(result.error).toBeDefined();
    });
  });

  describe('Error Handling and Edge Cases', () => {
    test('should handle git command failures gracefully', async () => {
      // Test with invalid repository path
      const invalidProcessor = new GitProcessor('/invalid/path');

      const result = await invalidProcessor.getCommits();

      expect(result.success).toBe(false);
      expect(result.error).toBeDefined();
    });

    test('should handle malformed commit hash', async () => {
      const result = await gitProcessor.getCommit('invalid-hash-format');

      expect(result.success).toBe(false);
      expect(result.error).toBeDefined();
    });

    test('should handle empty repository', async () => {
      // Create empty repository
      const emptyDir = await fs.mkdtemp(path.join(os.tmpdir(), 'empty-repo-'));
      const simpleGit = require('simple-git');
      const git = simpleGit({ baseDir: emptyDir });
      await git.init();
      await git.addConfig('user.name', 'Test User');
      await git.addConfig('user.email', 'test@example.com');

      const emptyProcessor = new GitProcessor(emptyDir);

      const commits = await emptyProcessor.getCommits();

      expect(commits).toHaveLength(0);

      await fs.remove(emptyDir);
    });

    test('should validate input parameters', () => {
      expect(() => {
        gitProcessor.isValidCommitDate(null);
      }).not.toThrow();

      expect(() => {
        gitProcessor.isValidCommitDate(undefined);
      }).not.toThrow();

      expect(() => {
        gitProcessor.isValidCommitDate(123);
      }).not.toThrow();
    });

    test('should handle concurrent operations', async () => {
      const operations = [
        gitProcessor.getCommits(),
        gitProcessor.getStatus(),
        gitProcessor.getCurrentBranch(),
        gitProcessor.getBranches()
      ];

      const results = await Promise.allSettled(operations);

      // All operations should complete without throwing
      results.forEach((result, index) => {
        expect(result.status).toBe('fulfilled');
        if (result.status === 'fulfilled') {
          expect(result.value).toBeDefined();
        }
      });
    });
  });

  describe('Integration Tests', () => {
    test('should complete complex workflow', async () => {
      // 1. Get current status
      const status = await gitProcessor.getStatus();
      expect(status.success).toBe(true);

      // 2. Create new branch
      const branchResult = await gitProcessor.createBranch('feature/test');
      expect(branchResult.success).toBe(true);

      // 3. Switch to new branch
      const switchResult = await gitProcessor.switchBranch('feature/test');
      expect(switchResult.success).toBe(true);

      // 4. Create new file and commit
      await fs.writeFile(path.join(testRepoPath, 'feature-file.txt'), 'Feature content');
      await git.add(['feature-file.txt']);
      await git.commit('Add feature file');

      // 5. Get commits on new branch
      const commits = await gitProcessor.getCommits();
      expect(commits.length).toBeGreaterThan(2);

      // 6. Modify commit message
      const messageResult = await gitProcessor.amendCommitMessage(
        commits[0].hash,
        'feat: add new feature file'
      );
      expect(messageResult.success).toBe(true);

      // 7. Create tag
      const tagResult = await gitProcessor.createTag('v1.1.0', commits[0].hash, 'Feature release');
      expect(tagResult.success).toBe(true);

      // 8. Switch back to main branch
      const backResult = await gitProcessor.switchBranch('main');
      expect(backResult.success).toBe(true);
    });

    test('should handle workflow with backup-like operations', async () => {
      // Create multiple commits to test batch operations
      for (let i = 3; i <= 5; i++) {
        await fs.writeFile(path.join(testRepoPath, `batch-file-${i}.txt`), `Batch content ${i}`);
        await git.add([`batch-file-${i}.txt`]);
        await git.commit(`Batch commit ${i}`);
      }

      // Get all commits
      const commits = await gitProcessor.getCommits();
      expect(commits.length).toBeGreaterThan(3);

      // Modify multiple commit dates
      const commitsWithDates = commits.slice(0, 3).map((commit, index) => ({
        hash: commit.hash,
        newDate: `2023-12-${String(index + 1).padStart(2, '0')}T10:00:00`
      }));

      const dateResult = await gitProcessor.amendMultipleCommitDates(commitsWithDates);
      expect(dateResult.success).toBe(true);
      expect(dateResult.processed).toBe(3);

      // Verify changes were applied
      const updatedCommits = await gitProcessor.getCommits();
      expect(updatedCommits.length).toBe(commits.length);
    });
  });
});