/**
 * Git History Rewriter - Comprehensive Tests
 */

const GitHistoryRewriter = require('../src/gitHistoryRewriter');
const fs = require('fs-extra');
const path = require('path');
const os = require('os');
const simpleGit = require('simple-git');

describe('GitHistoryRewriter', () => {
  let gitHistoryRewriter;
  let testRepoPath;
  let git;

  beforeEach(async () => {
    // Create temporary test directory
    testRepoPath = await fs.mkdtemp(path.join(os.tmpdir(), 'gctm-rewriter-test-'));

    // Initialize git repo
    git = simpleGit({ baseDir: testRepoPath });
    await git.init();
    await git.addConfig('user.name', 'Test User');
    await git.addConfig('user.email', 'test@example.com');
    await git.addConfig('commit.gpgsign', 'false');

    // Create test commits
    await fs.writeFile(path.join(testRepoPath, 'file1.txt'), 'Content 1');
    await git.add(['file1.txt']);
    await git.commit('Initial commit');

    await fs.writeFile(path.join(testRepoPath, 'file2.txt'), 'Content 2');
    await git.add(['file2.txt']);
    await git.commit('Second commit');

    gitHistoryRewriter = new GitHistoryRewriter(testRepoPath);
  });

  afterEach(async () => {
    // Clean up test directory
    await fs.remove(testRepoPath);
  });

  describe('Constructor', () => {
    test('should create instance with repo path', () => {
      const rewriter = new GitHistoryRewriter(testRepoPath);
      expect(rewriter.repoPath).toBe(testRepoPath);
      expect(rewriter.git).toBeDefined();
    });

    test('should handle missing repo path', () => {
      expect(() => {
        new GitHistoryRewriter('');
      }).toThrow('Repository path is required');
    });

    test('should handle non-existent directory', () => {
      expect(() => {
        new GitHistoryRewriter('/non/existent/path');
      }).toThrow('Repository directory does not exist');
    });
  });

  describe('Repository Validation', () => {
    test('should validate git repository', async () => {
      const isValid = await gitHistoryRewriter.isGitRepository();
      expect(isValid).toBe(true);
    });

    test('should handle non-git directory', async () => {
      const nonGitDir = await fs.mkdtemp(path.join(os.tmpdir(), 'non-git-'));
      const rewriter = new GitHistoryRewriter(nonGitDir);

      const isValid = await rewriter.isGitRepository();
      expect(isValid).toBe(false);

      await fs.remove(nonGitDir);
    });

    test('should check working directory status', async () => {
      const status = await gitHistoryRewriter.getWorkingDirectoryStatus();
      expect(status.success).toBe(true);
      expect(status.isClean).toBe(true);
    });

    test('should detect unclean working directory', async () => {
      // Create uncommitted changes
      await fs.writeFile(path.join(testRepoPath, 'uncommitted.txt'), 'Uncommitted content');

      const status = await gitHistoryRewriter.getWorkingDirectoryStatus();
      expect(status.success).toBe(true);
      expect(status.isClean).toBe(false);
      expect(status.hasUntrackedFiles).toBe(true);
    });
  });

  describe('Commit Operations', () => {
    test('should get commit list', async () => {
      const commits = await gitHistoryRewriter.getCommitList();
      expect(commits).toHaveLength(2);
      expect(commits[0]).toHaveProperty('hash');
      expect(commits[0]).toHaveProperty('message');
      expect(commits[0]).toHaveProperty('author');
      expect(commits[0]).toHaveProperty('date');
    });

    test('should get commit list with limit', async () => {
      const commits = await gitHistoryRewriter.getCommitList({ limit: 1 });
      expect(commits).toHaveLength(1);
    });

    test('should get commit details', async () => {
      const commits = await gitHistoryRewriter.getCommitList();
      const commitHash = commits[0].hash;

      const details = await gitHistoryRewriter.getCommitDetails(commitHash);
      expect(details.success).toBe(true);
      expect(details.commit).toHaveProperty('hash');
      expect(details.commit).toHaveProperty('message');
      expect(details.commit).toHaveProperty('diff');
    });

    test('should handle non-existent commit', async () => {
      const details = await gitHistoryRewriter.getCommitDetails('nonexistent');
      expect(details.success).toBe(false);
      expect(details.error).toContain('not found');
    });

    test('should get commit files', async () => {
      const commits = await gitHistoryRewriter.getCommitList();
      const commitHash = commits[0].hash;

      const files = await gitHistoryRewriter.getCommitFiles(commitHash);
      expect(files.success).toBe(true);
      expect(Array.isArray(files.files)).toBe(true);
    });
  });

  describe('Content Replacement', () => {
    test('should replace content in commit', async () => {
      const commits = await gitHistoryRewriter.getCommitList();
      const commitHash = commits[commits.length - 1].hash; // Get latest commit

      const replacements = [
        { pattern: 'Content 1', replacement: 'Modified Content 1' }
      ];

      const result = await gitHistoryRewriter.replaceContentInCommit(commitHash, replacements);
      expect(result.success).toBe(true);
      expect(result.modifiedFiles).toBeGreaterThan(0);
    });

    test('should handle multiple replacements', async () => {
      const commits = await gitHistoryRewriter.getCommitList();
      const commitHash = commits[commits.length - 1].hash;

      const replacements = [
        { pattern: 'Content 1', replacement: 'New Content 1' },
        { pattern: 'Content 2', replacement: 'New Content 2' }
      ];

      const result = await gitHistoryRewriter.replaceContentInCommit(commitHash, replacements);
      expect(result.success).toBe(true);
    });

    test('should handle regex replacements', async () => {
      const commits = await gitHistoryRewriter.getCommitList();
      const commitHash = commits[commits.length - 1].hash;

      const replacements = [
        { pattern: /Content \d+/g, replacement: 'Replaced Content' }
      ];

      const result = await gitHistoryRewriter.replaceContentInCommit(commitHash, replacements);
      expect(result.success).toBe(true);
    });

    test('should handle non-matching patterns', async () => {
      const commits = await gitHistoryRewriter.getCommitList();
      const commitHash = commits[commits.length - 1].hash;

      const replacements = [
        { pattern: 'NonExistentPattern', replacement: 'Something' }
      ];

      const result = await gitHistoryRewriter.replaceContentInCommit(commitHash, replacements);
      expect(result.success).toBe(true);
      expect(result.modifiedFiles).toBe(0);
    });

    test('should validate replacements', () => {
      const invalidReplacements = [
        { pattern: '', replacement: 'something' } // Empty pattern
      ];

      expect(() => {
        gitHistoryRewriter.validateReplacements(invalidReplacements);
      }).toThrow('Invalid replacement pattern');
    });
  });

  describe('Commit Message Editing', () => {
    test('should edit commit message', async () => {
      const commits = await gitHistoryRewriter.getCommitList();
      const commitHash = commits[commits.length - 1].hash;

      const newMessage = 'Updated commit message';
      const result = await gitHistoryRewriter.editCommitMessage(commitHash, newMessage);

      expect(result.success).toBe(true);

      // Verify the message was changed
      const details = await gitHistoryRewriter.getCommitDetails(commitHash);
      expect(details.commit.message).toBe(newMessage);
    });

    test('should handle empty commit message', async () => {
      const commits = await gitHistoryRewriter.getCommitList();
      const commitHash = commits[commits.length - 1].hash;

      const result = await gitHistoryRewriter.editCommitMessage(commitHash, '');
      expect(result.success).toBe(false);
      expect(result.error).toContain('empty');
    });

    test('should preserve commit metadata when editing message', async () => {
      const commits = await gitHistoryRewriter.getCommitList();
      const originalCommit = commits[commits.length - 1];
      const commitHash = originalCommit.hash;

      const newMessage = 'New message with metadata preserved';
      const result = await gitHistoryRewriter.editCommitMessage(commitHash, newMessage);

      expect(result.success).toBe(true);

      const details = await gitHistoryRewriter.getCommitDetails(commitHash);
      expect(details.commit.author).toBe(originalCommit.author);
      expect(details.commit.message).toBe(newMessage);
    });
  });

  describe('Date Modification', () => {
    test('should modify commit date', async () => {
      const commits = await gitHistoryRewriter.getCommitList();
      const commitHash = commits[commits.length - 1].hash;

      const newDate = '2023-01-01T12:00:00';
      const result = await gitHistoryRewriter.modifyCommitDate(commitHash, newDate);

      expect(result.success).toBe(true);

      // Verify the date was changed
      const details = await gitHistoryRewriter.getCommitDetails(commitHash);
      expect(details.commit.date).toContain('2023-01-01');
    });

    test('should handle invalid date format', async () => {
      const commits = await gitHistoryRewriter.getCommitList();
      const commitHash = commits[commits.length - 1].hash;

      const invalidDate = 'invalid-date';
      const result = await gitHistoryRewriter.modifyCommitDate(commitHash, invalidDate);

      expect(result.success).toBe(false);
      expect(result.error).toContain('Invalid date format');
    });

    test('should modify multiple commit dates', async () => {
      const commits = await gitHistoryRewriter.getCommitList();
      const commitHashes = commits.map(c => c.hash);

      const dates = [
        '2023-01-01T12:00:00',
        '2023-01-02T13:00:00'
      ];

      const result = await gitHistoryRewriter.modifyMultipleCommitDates(commitHashes, dates);
      expect(result.success).toBe(true);
      expect(result.modifiedCommits).toBe(2);
    });

    test('should handle date range generation', () => {
      const startDate = '2023-01-01';
      const endDate = '2023-01-05';
      const count = 5;

      const dates = gitHistoryRewriter.generateDateRange(startDate, endDate, count);
      expect(dates).toHaveLength(5);

      // Check that dates are in chronological order
      const sortedDates = [...dates].sort();
      expect(dates).toEqual(sortedDates);
    });
  });

  describe('Backup and Restore', () => {
    test('should create backup before operations', async () => {
      const backupId = await gitHistoryRewriter.createBackup({
        description: 'Test backup'
      });

      expect(backupId).toBeDefined();
      expect(typeof backupId).toBe('string');
    });

    test('should restore from backup', async () => {
      // Create backup
      const backupId = await gitHistoryRewriter.createBackup();

      // Make a change
      const commits = await gitHistoryRewriter.getCommitList();
      const commitHash = commits[commits.length - 1].hash;
      await gitHistoryRewriter.editCommitMessage(commitHash, 'Modified message');

      // Restore from backup
      const result = await gitHistoryRewriter.restoreFromBackup(backupId);
      expect(result.success).toBe(true);

      // Verify the change was reverted
      const details = await gitHistoryRewriter.getCommitDetails(commitHash);
      expect(details.commit.message).not.toBe('Modified message');
    });

    test('should handle missing backup', async () => {
      const result = await gitHistoryRewriter.restoreFromBackup('nonexistent-backup');
      expect(result.success).toBe(false);
      expect(result.error).toContain('not found');
    });

    test('should list available backups', async () => {
      // Create some backups
      await gitHistoryRewriter.createBackup({ description: 'Backup 1' });
      await gitHistoryRewriter.createBackup({ description: 'Backup 2' });

      const backups = await gitHistoryRewriter.listBackups();
      expect(Array.isArray(backups)).toBe(true);
      expect(backups.length).toBeGreaterThanOrEqual(2);

      // Check structure
      backups.forEach(backup => {
        expect(backup).toHaveProperty('id');
        expect(backup).toHaveProperty('createdAt');
        expect(backup).toHaveProperty('description');
      });
    });
  });

  describe('Error Handling', () => {
    test('should handle git command failures', async () => {
      // Test with invalid git command
      const invalidRewriter = new GitHistoryRewriter('/invalid/path');
      const result = await invalidRewriter.getCommitList();

      expect(result.success).toBe(false);
      expect(result.error).toBeDefined();
    });

    test('should handle file system errors', async () => {
      // Test with read-only directory (simulate permission error)
      const readOnlyDir = await fs.mkdtemp(path.join(os.tmpdir(), 'readonly-'));
      try {
        await fs.chmod(readOnlyDir, 0o444); // Read-only

        const rewriter = new GitHistoryRewriter(readOnlyDir);
        const result = await rewriter.createBackup();

        expect(result.success).toBe(false);
      } finally {
        await fs.chmod(readOnlyDir, 0o755); // Restore permissions
        await fs.remove(readOnlyDir);
      }
    });

    test('should handle concurrent operations', async () => {
      const commits = await gitHistoryRewriter.getCommitList();
      const commitHash = commits[commits.length - 1].hash;

      // Start multiple operations simultaneously
      const operations = [
        gitHistoryRewriter.editCommitMessage(commitHash, 'Message 1'),
        gitHistoryRewriter.editCommitMessage(commitHash, 'Message 2'),
        gitHistoryRewriter.editCommitMessage(commitHash, 'Message 3')
      ];

      const results = await Promise.allSettled(operations);

      // At least one should succeed, but concurrent access should be handled gracefully
      const successfulResults = results.filter(r => r.status === 'fulfilled' && r.value.success);
      const failedResults = results.filter(r => r.status === 'rejected' || !r.value.success);

      expect(successfulResults.length + failedResults.length).toBe(3);
    });
  });

  describe('Integration Tests', () => {
    test('should complete full history rewriting workflow', async () => {
      // Create more test data
      await fs.writeFile(path.join(testRepoPath, 'config.js'), 'API_KEY="secret123"');
      await git.add(['config.js']);
      await git.commit('Add config file');

      // 1. Create backup
      const backupId = await gitHistoryRewriter.createBackup({
        description: 'Before sanitization'
      });

      // 2. Get all commits
      const commits = await gitHistoryRewriter.getCommitList();
      expect(commits.length).toBe(3);

      // 3. Replace sensitive content
      const replacements = [
        { pattern: 'secret123', replacement: '***HIDDEN***' }
      ];

      const contentResult = await gitHistoryRewriter.replaceContentInCommit(
        commits[0].hash, // Last commit
        replacements
      );
      expect(contentResult.success).toBe(true);

      // 4. Update commit message
      const messageResult = await gitHistoryRewriter.editCommitMessage(
        commits[0].hash,
        'feat: add sanitized config'
      );
      expect(messageResult.success).toBe(true);

      // 5. Modify commit date
      const dateResult = await gitHistoryRewriter.modifyCommitDate(
        commits[0].hash,
        '2023-12-25T10:00:00'
      );
      expect(dateResult.success).toBe(true);

      // 6. Verify all changes
      const finalDetails = await gitHistoryRewriter.getCommitDetails(commits[0].hash);
      expect(finalDetails.commit.message).toBe('feat: add sanitized config');
      expect(finalDetails.commit.date).toContain('2023-12-25');
    });
  });
});